"""
Report generation utilities.

Shared functions for generating HTML, PDF, and Excel reports
across all toolkit scripts.
"""

import json
import logging
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)


def generate_html_report(
    title: str,
    content_sections: list[dict[str, Any]],
    output_path: Path,
    metadata: dict[str, Any] | None = None,
) -> Path:
    """
    Generate a standalone HTML report.

    Args:
        title: Report title
        content_sections: List of dicts with 'heading' and 'body' (HTML string)
        output_path: Where to write the HTML file
        metadata: Optional metadata (baseline, date, author, etc.)

    Returns:
        Path to the generated HTML file
    """
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    meta = metadata or {}

    sections_html = ""
    for section in content_sections:
        sections_html += f"""
        <section>
            <h2>{section.get('heading', '')}</h2>
            {section.get('body', '')}
        </section>
        """

    meta_html = ""
    if meta:
        meta_items = "".join(
            f"<li><strong>{k}:</strong> {v}</li>" for k, v in meta.items()
        )
        meta_html = f"<ul class='metadata'>{meta_items}</ul>"

    html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            color: #1a1a1a;
            background: #fafafa;
        }}
        h1 {{
            color: #0d47a1;
            border-bottom: 3px solid #0d47a1;
            padding-bottom: 0.5rem;
        }}
        h2 {{
            color: #1565c0;
            margin-top: 2rem;
        }}
        .metadata {{
            background: #e3f2fd;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            list-style: none;
        }}
        .metadata li {{
            margin: 0.3rem 0;
        }}
        .timestamp {{
            color: #666;
            font-size: 0.9rem;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 0.5rem 0.75rem;
            text-align: left;
        }}
        th {{
            background: #1565c0;
            color: white;
        }}
        tr:nth-child(even) {{
            background: #f5f5f5;
        }}
        .status-implemented {{ color: #2e7d32; font-weight: bold; }}
        .status-partial {{ color: #f57f17; font-weight: bold; }}
        .status-not-implemented {{ color: #c62828; font-weight: bold; }}
        .status-inherited {{ color: #1565c0; font-weight: bold; }}
        .score-high {{ color: #2e7d32; }}
        .score-medium {{ color: #f57f17; }}
        .score-low {{ color: #c62828; }}
    </style>
</head>
<body>
    <h1>{title}</h1>
    <p class="timestamp">Generated: {timestamp}</p>
    {meta_html}
    {sections_html}
    <footer>
        <hr>
        <p class="timestamp">
            Generated by FedRAMP Readiness Assessment Toolkit v0.1.0
        </p>
    </footer>
</body>
</html>"""

    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(html)
    logger.info(f"HTML report written to {output_path}")
    return output_path


def generate_excel_report(
    title: str,
    sheets_data: dict[str, list[dict]],
    output_path: Path,
) -> Path:
    """
    Generate an Excel report with multiple sheets.

    Args:
        title: Report title (used as first sheet name)
        sheets_data: Dict mapping sheet names to lists of row dicts
        output_path: Where to write the .xlsx file

    Returns:
        Path to the generated Excel file
    """
    try:
        import openpyxl
        from openpyxl.styles import Font, PatternFill, Alignment
    except ImportError:
        raise ImportError("openpyxl is required for Excel reports: pip install openpyxl")

    wb = openpyxl.Workbook()

    for i, (sheet_name, rows) in enumerate(sheets_data.items()):
        if i == 0:
            ws = wb.active
            ws.title = sheet_name[:31]  # Excel sheet name limit
        else:
            ws = wb.create_sheet(title=sheet_name[:31])

        if not rows:
            continue

        # Header row
        headers = list(rows[0].keys())
        header_fill = PatternFill(start_color="1565C0", end_color="1565C0", fill_type="solid")
        header_font = Font(color="FFFFFF", bold=True)

        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = Alignment(horizontal="center")

        # Data rows
        for row_idx, row_data in enumerate(rows, 2):
            for col, header in enumerate(headers, 1):
                ws.cell(row=row_idx, column=col, value=row_data.get(header, ""))

        # Auto-width columns
        for col in ws.columns:
            max_length = max(len(str(cell.value or "")) for cell in col)
            ws.column_dimensions[col[0].column_letter].width = min(max_length + 2, 50)

    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    wb.save(output_path)
    logger.info(f"Excel report written to {output_path}")
    return output_path
